{
  "name": "persistencejs",
  "version": "0.2.5",
  "engine": "node >=0.2.0",
  "author": {
    "name": "Zef Hemel"
  },
  "directories": {
    "lib": "./lib"
  },
  "contributors": [
    {
      "name": "Zef Hemel",
      "email": "zef@zef.me"
    },
    {
      "name": "Fabio Rehm",
      "email": "fgrehm@gmail.com"
    },
    {
      "name": "Lukas Berns"
    },
    {
      "name": "Roberto Saccon",
      "email": "rsaccon@gmail.com"
    },
    {
      "name": "Wilker LÃºcio",
      "email": "wilkerlucio@gmail.com"
    },
    {
      "name": "Bruno Jouhier",
      "email": "bjouhier@gmail.com"
    },
    {
      "name": "Robin Wenglewski",
      "email": "robin@wenglewski.de"
    },
    {
      "name": "Matthias Hochgatterer",
      "email": "matthias.hochgatterer@gmail.com"
    },
    {
      "name": "Chris Chua",
      "email": "chris.sirhc@gmail.com"
    },
    {
      "name": "Mike Smullin",
      "email": "mike@smullindesign.com"
    },
    {
      "name": "Masahiro Hayashi",
      "email": "hayashi.masahiro@gmail.com"
    },
    {
      "name": "Mick Staugaard",
      "email": "mick@staugaard.com"
    },
    {
      "name": "Shane Tomlinson",
      "email": "set117@gmail.com"
    },
    {
      "name": "Eugene Ware",
      "email": "eugene.ware@nextharbour.com"
    }
  ],
  "readme": "persistence.js\r\n==============\r\n`persistence.js` is a asynchronous Javascript object-relational\r\nmapper library. It can be used both in the web browser and on\r\nthe server using [node.js](http://nodejs.org). It currently\r\nsupports 4 types of data stores:\r\n\r\n* [HTML5 WebSQL database](http://dev.w3.org/html5/webdatabase/), a\r\n  somewhat controversial part of HTML5 that is supported in Webkit\r\n  browsers, specifically on mobile devices, including iPhone, Android\r\n  and Palm's WebOS. \r\n* [Google Gears](http://gears.google.com), a browser plug-in that adds\r\n  a number of feature to the browser, including a in-browser database.\r\n* [MySQL](http://www.mysql.com), using the\r\n  [node-mysql](http://github.com/felixge/node-mysql), node.js module\r\n  on the server.\r\n* In-memory, as a fallback. Keeps the database in memory and is\r\n  cleaned upon a page refresh (or server restart), unless saved to\r\n  [localStorage](http://dev.w3.org/html5/webstorage/).\r\n\r\nThere is also an experimental support for [Qt 4.7 Declarative UI\r\nframework\r\n(QML)](http://doc.trolltech.org/4.7-snapshot/declarativeui.html) which\r\nis an extension to JavaScript.\r\n\r\nFor browser use, `persistence.js` has no dependencies on any other\r\nframeworks, other than the Google Gears [initialization\r\nscript](http://code.google.com/apis/gears/gears_init.js), in case you\r\nwant to enable Gears support.\r\n\r\nPlug-ins\r\n--------\r\n\r\nThere are a few `persistence.js` plug-ins available that add functionality:\r\n\r\n* `persistence.search.js`, adds simple full-text search capabilities,\r\n  see `docs/search.md` for more information.\r\n* `persistence.migrations.js`, supports data migrations (changes to\r\n  the database schema), see `docs/migrations.md` for more information.\r\n* `persistence.sync.js`, supports database synchronization with a\r\n  remote server, see `docs/sync.md` for more information.\r\n* `jquery.persistence.js`, adds jQuery integration, including \r\n  jQuery-mobile ajax request interception and re-routing to persistencejs,\r\n  see `docs/jquery.md` for more information and `demo/jquerymobile` for a \r\n  simple demo.\r\n\r\nA Brief Intro to Async Programming\r\n----------------------------------\r\n\r\nIn browsers, Javascript and the web page's rendering engine share\r\na single thread. The result of this is that only one thing can happen\r\nat a time. If a database query would be performed _synchronously_,\r\nlike in many other programming environments like Java and PHP the\r\nbrowser would freeze from the moment the query was issued until the\r\nresults came back. Therefore, many APIs in Javascript are defined as\r\n_asynchronous_ APIs, which mean that they do not block when an\r\n\"expensive\" computation is performed, but instead provide the call\r\nwith a function that will be invoked once the result is known. In the\r\nmeantime, the browser can perform other duties.\r\n\r\nFor instance, a synchronous database call call would look as follows:\r\n\r\n    var results = db.query(\"SELECT * FROM Table\");\r\n    for(...) { ... }\r\n\r\nThe execution of the first statement could take half a second, during\r\nwhich the browser doesn't do anything else. By contrast, the\r\nasynchronous version looks as follows:\r\n\r\n    db.query(\"SELECT * FROM Table\", function(results) {\r\n      for(...) { ... }\r\n    });\r\n\r\nNote that there will be a delay between the `db.query` call and the\r\nresult being available and that while the database is processing the\r\nquery, the execution of the Javascript continues. To make this clear,\r\nconsider the following program:\r\n    \r\n    db.query(\"SELECT * FROM Table\", function(results) {\r\n      console.log(\"hello\");\r\n    });\r\n    console.log(\"world\");\r\n\r\nAlthough one could assume this would print \"hello\", followed by\r\n\"world\", the result will likely be that \"world\" is printed before\r\n\"hello\", because \"hello\" is only printed when the results from the\r\nquery are available. This is a tricky thing about asynchronous\r\nprogramming that a Javascript developer will have to get used to.\r\n\r\nUsing persistence.js in the browser\r\n===================================\r\n\r\nBrowser support\r\n---------------\r\n\r\n* Modern webkit browsers (Google Chrome and Safari)\r\n* Firefox (through Google Gears)\r\n* Opera\r\n* Android browser (tested on 1.6 and 2.x)\r\n* iPhone browser (iPhone OS 3+)\r\n* Palm WebOS (tested on 1.4.0)\r\n* Other browsers supporting `localStorage` (e.g. Firefox)\r\n\r\n(The following is being worked on:)\r\nInternet Explorer is likely not supported (untested) because it\r\nlacks `__defineGetter__` and `__defineSetter__` support, which\r\n`persistence.js` uses heavily. This may change in IE 9.\r\n\r\nSetting up\r\n----------\r\n\r\nTo use `persistence.js` you need to clone the git repository:\r\n\r\n    git clone git://github.com/zefhemel/persistencejs.git\r\n\r\nTo use it you need to copy `lib/persistence.js` to your web directory,\r\nas well as any data stores you want to use. Note that the `mysql` and\r\n`websql` stores both depend on the `sql` store. A typical setup\r\nrequires you to copy at least `lib/persistence.js`,\r\n`lib/persistence.store.sql.js` and `lib/persistence.store.websql.js` to your\r\nweb directory. You can then load them as follows:\r\n\r\n    <script src=\"persistence.js\" type=\"application/javascript\"></script>\r\n    <script src=\"persistence.store.sql.js\" type=\"application/javascript\"></script>\r\n    <script src=\"persistence.store.websql.js\" type=\"application/javascript\"></script>\r\n\r\nIf you want to use the in-memory store (in combination with\r\n`localStorage`) you also need the `persistence.store.memory.js`\r\nincluded.\r\n\r\n\r\nSetup your database\r\n-------------------\r\n\r\nYou need to explicitly configure the data store you want to use,\r\nconfiguration of the data store is store-specific. The WebSQL store\r\n(which includes Google Gears support) is configured as follows:\r\n\r\n    persistence.store.websql.config(persistence, 'yourdbname', 'A database description', 5 * 1024 * 1024);\r\n\r\nThe first argument is always supposed to be `persistence`. The second\r\nin your database name (it will create it if it does not already exist,\r\nthe third is a description for you database, the last argument is the\r\nmaximum size of your database in bytes (5MB in this example).\r\n\r\nThe in-memory store\r\n---------------------------------------\r\n\r\nThe in-memory store is offered as a fallback for browsers that do not\r\nsupport any of the other supported stores (e.g. WebSQL or Gears). In\r\nprincipal, it only keeps data in memory, which means that navigating\r\naway from the page (including a reload or tab close) will result in\r\nthe loss of all data.\r\n\r\nA way around this is using the `persistence.saveToLocalStorage` and\r\n`persistence.loadFromLocalStorage` functions that can save the entire\r\ndatabase to the [localStorage](http://dev.w3.org/html5/webstorage/), which\r\nis persisted indefinitely (similar to WebSQL).\r\n\r\nIf you're going to use the in-memory store, you can configure it as follows:\r\n\r\n    persistence.store.memory.config(persistence);\r\n\r\nThen, if desired, current data can be loaded from the localStorage using:\r\n\r\n    persistence.loadFromLocalStorage(function() {\r\n      alert(\"All data loaded!\");\r\n    });\r\n\r\nAnd saved using:\r\n\r\n    persistence.saveToLocalStorage(function() {\r\n      alert(\"All data saved!\");\r\n    });\r\n\r\nDrawbacks of the in-memory store:\r\n\r\n* Performance: All actions that are typically performed by a database\r\n  (sorting, filtering), are now all performed in-memory using\r\n  Javascript.\r\n* Limited database size: Loading and saving requires serialization of\r\n  all data from and to JSON, which gets more expensive as your dataset\r\n  grows. Most browsers have a maximum size of 5MB for `localStorage`.\r\n* Synchronous behavior: Although the API is asynchronous, all\r\n  persistence actions will be performed synchronously on the main\r\n  Javascript thread, which may make the browser less responsive.\r\n\r\nSchema definition\r\n-----------------\r\n\r\nA data model is declared using `persistence.define`. The following two\r\ndefinitions define a `Task` and `Category` entity with a few simple\r\nproperties. The property types are based on [SQLite\r\ntypes](http://www.sqlite.org/datatype3.html), specifically supported\r\ntypes are (but any SQLite type is supported):\r\n\r\n* `TEXT`: for textual data \r\n* `INT`: for numeric values\r\n* `BOOL`: for boolean values (`true` or `false`)\r\n* `DATE`: for date/time value (with precision of 1 second)\r\n* `JSON`: a special type that can be used to store arbitrary\r\n  [JSON](http://www.json.org) data. Note that this data can not be used\r\n  to filter or sort in any sensible way. If internal changes are made to a `JSON`\r\n  property, `persistence.js` may not register them. Therefore, a manual\r\n  call to `anObj.markDirty('jsonPropertyName')` is required before calling\r\n  `persistence.flush`.\r\n\r\nExample use:\r\n    \r\n    var Task = persistence.define('Task', {\r\n      name: \"TEXT\",\r\n      description: \"TEXT\",\r\n      done: \"BOOL\"\r\n    });\r\n\r\n    var Category = persistence.define('Category', {\r\n      name: \"TEXT\",\r\n      metaData: \"JSON\"\r\n    });\r\n\r\n    var Tag = persistence.define('Tag', {\r\n      name: \"TEXT\"\r\n    });\r\n\r\nThe returned values are constructor functions and can be used to\r\ncreate new instances of these entities later.\r\n\r\nIt is possible to create indexes on one or more columns using\r\n`EntityName.index`, for instance:\r\n\r\n    Task.index('done');\r\n    Task.index(['done', 'name']);\r\n\r\nThese indexes can also be used to impose unique constraints :\r\n\r\n    Task.index(['done', 'name'],{unique:true});\r\n\r\nRelationships between entities are defined using the constructor\r\nfunction's `hasMany` call:\r\n\r\n    // This defines a one-to-many relationship:\r\n    Category.hasMany('tasks', Task, 'category');\r\n    // These two definitions define a many-to-many relationship\r\n    Task.hasMany('tags', Tag, 'tasks');\r\n    Tag.hasMany('tasks', Task, 'tags');\r\n        \r\nThe first statement defines a `tasks` relationship on category objects\r\ncontaining a `QueryCollection` (see the section on query collections\r\nlater) of `Task`s, it also defines an inverse relationship on `Task`\r\nobjects with the name `category`. The last two statements define a\r\nmany-to-many relationships between `Task` and `Tag`. `Task` gets a\r\n`tags` property (a `QueryCollection`) containing all its tags and vice\r\nversa, `Tag` gets a `tasks` property containing all of its tasks.\r\n\r\nThe defined entity definitions are synchronized (activated) with the\r\ndatabase using a `persistence.schemaSync` call, which takes a callback\r\nfunction (with a newly created transaction as an argument), that is called\r\nwhen the schema synchronization has completed, the callback is\r\noptional.\r\n\r\n    persistence.schemaSync();\r\n    // or\r\n    persistence.schemaSync(function(tx) { \r\n      // tx is the transaction object of the transaction that was\r\n      // automatically started\r\n    });\r\n\r\nThere is also a migrations plugin you can check out, documentation can be found\r\nin [persistence.migrations.docs.md](migrations/persistence.migrations.docs.md) file.\r\n\r\nMix-ins\r\n-------\r\n\r\nYou can also define mix-ins and apply them to entities of the model. \r\n\r\nA mix-in definition is similar to an entity definition, except using\r\n`defineMixin` rather than just `define`. For example:\r\n\r\n    var Annotatable = persistence.defineMixin('Annotatable', {\r\n      lastAnnotated: \"DATE\"\r\n    });\r\n\r\nYou can define relationships between mix-in and entities. For example:\r\n\r\n    // A normal entity\r\n    var Note = persistence.define('Note', {\r\n      text: \"TEXT\"\r\n    });\r\n  \r\n    // relationship between a mix-in and a normal entity\r\n    Annotatable.hasMany('notes', Note, 'annotated');\r\n\r\nOnce you have defined a mix-in, you can apply it to any entity of your model, \r\nwith the `Entity.is(mixin)` method. For example:\r\n\r\n    Project.is(Annotatable);\r\n    Task.is(Annotatable);\r\n    \r\nNow, your `Project` and `Task` entities have an additional `lastAnnotated` property.\r\nThey also have a one to many relationship called `notes` to the `Note` entity. \r\nAnd you can also traverse the reverse relationship from a `Note` to its `annotated` object.\r\n\r\nNote that `annotated` is a polymorphic relationship as it may yield either a `Project` \r\nor a `Task` (or any other entity which is `Annotatable').\r\n\r\nNote: Prefetch is not allowed (yet) on a relationship that targets a mixin. In the example above\r\nyou cannot prefetch the `annotated` relationship when querying the `Note` entity.\r\n    \r\nNotes: this feature is very experimental at this stage. It needs more testing.\r\n  Support for \"is a\" relationships (classical inheritance) is also in the works.\r\n\r\nCreating and manipulating objects\r\n---------------------------------\r\n\r\nNew objects can be instantiated with the constructor functions.\r\nOptionally, an object with initial property values can be passed as\r\nwell, or the properties may be set later:\r\n\r\n    var task = new Task();\r\n    var category = new Category({name: \"My category\"});\r\n    category.metaData = {rating: 5};\r\n    var tag = new Tag();\r\n    tag.name = \"work\";\r\n\r\nMany-to-one relationships are accessed using their specified name, e.g.:\r\n    task.category = category;\r\n\r\nOne-to-many and many-to-many relationships are access and manipulated\r\nthrough the `QueryCollection` API that will be discussed later:\r\n\r\n    task.tags.add(tag);\r\n    tasks.tags.remove(tag);\r\n    tasks.tags.list(tx, function(allTags) { console.log(allTags); });\r\n\r\nPersisting/removing objects\r\n---------------------------\r\n\r\nSimilar to [hibernate](http://www.hibernate.org), `persistence.js`\r\nuses a tracking mechanism to determine which objects' changes have to\r\nbe persisted to the database. All objects retrieved from the database\r\nare automatically tracked for changes. New entities can be tracked to\r\nbe persisted using the `persistence.add` function:\r\n        \r\n    var c = new Category({name: \"Main category\"});\r\n    persistence.add(c);\r\n    for ( var i = 0; i < 5; i++) {\r\n      var t = new Task();\r\n      t.name = 'Task ' + i;\r\n      t.done = i % 2 == 0;\r\n      t.category = c;\r\n      persistence.add(t);\r\n    }\r\n\r\nObjects can also be removed from the database:\r\n\r\n    persistence.remove(c);\r\n\r\nAll changes made to tracked objects can be flushed to the database by\r\nusing `persistence.flush`, which takes a transaction object and\r\ncallback function as arguments. A new transaction can be started using\r\n`persistence.transaction`:\r\n    \r\n    persistence.transaction(function(tx) {\r\n      persistence.flush(tx, function() {\r\n        alert('Done flushing!');\r\n      });\r\n    });\r\n\r\nFor convenience, it is also possible to not specify a transaction or\r\ncallback, in that case a new transaction will be started\r\nautomatically. For instance:\r\n\r\n    persistence.flush();\r\n    // or, with callback\r\n    persistence.flush(function() {\r\n      alert('Done flushing');\r\n    });\r\n\r\nNote that when no callback is defined, the flushing still happens\r\nasynchronously.\r\n\r\n__Important__: Changes and new objects will not be persisted until you\r\nexplicitly call `persistence.flush()`. The exception to this rule is\r\nusing the `list(...)` method on a database `QueryCollection`, which also\r\nflushes first, although this behavior may change in the future. \r\n\r\nDumping and restoring data\r\n--------------------------\r\n\r\nThe library supports two kinds of dumping and restoring data.\r\n\r\n`persistence.dump` can be used to create an object containing a full\r\ndump of a database. Naturally, it is adviced to only do this with\r\nsmaller databases. Example:\r\n\r\n    persistence.dump(tx, [Task, Category], function(dump) {\r\n      console.log(dump);\r\n    });\r\n\r\nThe `tx` is left out, a new transaction will be started for the\r\noperation. If the second argument is left out, `dump` defaults\r\nto dumping _all_ defined entities.\r\n\r\nThe dump format is:\r\n    \r\n    {\"entity-name\": [list of instances],\r\n     ...}\r\n\r\n`persistence.load` is used to restore the dump produced by\r\n`persistence.dump`. Usage:\r\n\r\n    persistence.load(tx, dumpObj, function() {\r\n      alert('Dump restored!');\r\n    });\r\n\r\nThe `tx` argument can be left out to automatically start a new\r\ntransaction. Note that `persistence.load` does not empty the database\r\nfirst, it simply attempts to add all objects to the database. If\r\nobjects with, e.g. the same ID already exist, this will fail.\r\n\r\nSimilarly, `persistence.loadFromJson` and `persistence.dumpToJson`\r\nrespectively load and dump all the database's data as JSON strings.\r\n\r\nEntity constructor functions\r\n----------------------------\r\n\r\nThe constructor function returned by a `persistence.define` call\r\ncannot only be used to instantiate new objects, it also has some\r\nuseful methods of its own:\r\n\r\n* `EntityName.all([session])` returns a query collection containing\r\nall\r\n  persisted instances of that object. The `session` argument is\r\n  optional and only required when `persistence.js` is used in\r\n  multi-session mode.\r\n* `EntityName.load([session], [tx], id, callback)` loads an particular\r\n  object from the database by id or returns `null` if it has not been\r\n  found.\r\n* `EntityName.findBy([session], [tx], property, value, callback)` searches\r\n  for a particular object based on a property value (this is assumed to\r\n  be unique), the callback function is called with the found object or\r\n  `null` if it has not been found.\r\n* `EntityName.index([col1, col2, ..., colN], options)` creates an index on a column\r\n  of a combination of columns, for faster searching. If options.unique is true,\r\n  the index will impose a unique constraint on the values of the columns.\r\n\r\nAnd of course the methods to define relationships to other entities:\r\n\r\n* `EntityName.hasMany(property, Entity, inverseProperty)` defines a\r\n  1:N or N:M relationship (depending on the inverse property)\r\n* `EntityName.hasOne(property, Entity)` defines a 1:1 or N:1\r\n  relationship\r\n\r\n\r\nEntity objects\r\n--------------\r\n\r\nEntity instances also have a few predefined properties and methods you\r\nshould be aware of:\r\n\r\n* `obj.id`, contains the identifier of your entity, this is a\r\n  automatically generated (approximation of a) UUID. You should\r\n  never write to this property.\r\n* `obj.fetch(prop, callback)`, if an object has a `hasOne`\r\n   relationship to another which has not yet been fetched from the\r\n   database (e.g. when `prefetch` wasn't used), you can fetch in manually\r\n   using `fetch`. When the property object is retrieved the callback function\r\n   is invoked with the result, the result is also cached in the entity\r\n   object itself.\r\n* `obj.selectJSON([tx], propertySpec, callback)`, sometime you need to extract\r\n  a subset of data from an entity. You for instance need to post a\r\n  JSON representation of your entity, but do not want to include all\r\n  properties. `selectJSON` allows you to do that. The `propertySpec`\r\n  arguments expects an array with property names. Some examples:\r\n   * `['id', 'name']`, will return an object with the id and name property of this entity\r\n   * `['*']`, will return an object with all the properties of this entity, not recursive\r\n   * `['project.name']`, will return an object with a project property which has a name \r\n     property containing the project name (hasOne relationship)\r\n   * `['project.[id, name]']`, will return an object with a project property which has an\r\n     id and name property containing the project name (hasOne relationship)\r\n   * `['tags.name']`, will return an object with an array `tags` property containing \r\n     objects each with a single property: name\r\n       \r\n\r\nQuery collections\r\n-----------------\r\n\r\nA core concept of `persistence.js` is the `QueryCollection`. A\r\n`QueryCollection` represents a (sometimes) virtual collection that can\r\nbe filtered, ordered or paginated. `QueryCollection`s are somewhate\r\ninspired by [Google AppEngine's Query\r\nclass](http://code.google.com/appengine/docs/python/datastore/queryclass.html).\r\nA `QueryCollection` has the following methods:\r\n\r\n* `filter(property, operator, value)`  \r\n  Returns a new `QueryCollection` that adds a filter, filtering a\r\n  certain property based on an operator and value. Supported operators\r\n  are '=', '!=', '<', '<=', '>', '>=', 'in' and 'not in'. Example:\r\n  `.filter('done', '=', true)`\r\n* `or(filter)`  \r\n  Returns a new `QueryCollection` that contains items either matching\r\n  the filters specified before calling `or`, or the filter represented\r\n  in the argument. The `filter` argument is of a `Filter` type, there\r\n  are three types of filters:\r\n  - `persistence.PropertyFilter`, which filters on properties (internally called when `filter(...)` is used.  \r\n    Example: `new persistence.PropertyFilter('done', '=', true)`\r\n  - `persistence.AndFilter`, which is passed two filter objects as arguments, both of which should be true.\r\n    Example: `new persistence.AndFilter(new persistence.PropertyFilter('done', '=', true), new persistence.PropertyFilter('archived', '=', true))`\r\n  - `persistence.OrFilter`, which is passed two filter objects as arguments, one of which should be true.\r\n    Example: `new persistence.OrFilter(new persistence.PropertyFilter('done', '=', true), new persistence.PropertyFilter('archived', '=', true))`\r\n* `and(filter)`  \r\n  same as `or(filter)` except that both conditions should hold for items to be in the collection. \r\n* `order(property, ascending)`  \r\n  Returns a new `QueryCollection` that will order its results by the\r\n  property specified in either an ascending (ascending === true) or\r\n  descending (ascending === false) order.\r\n* `limit(n)`  \r\n  Returns a new `QueryCollection` that limits the size of the result\r\n  set to `n` items. Useful for pagination.\r\n* `skip(n)`  \r\n  Returns a new `QueryCollection` that skips the first `n` results.\r\n  Useful for pagination.\r\n* `prefetch(rel)`  \r\n  Returns a new `QueryCollection` that prefetches entities linked\r\n  through relationship `rel`, note that this only works for one-to-one\r\n  and many-to-one relationships.\r\n* `add(obj)`  \r\n  Adds object `obj` to the collection.\r\n* `remove(obj)`  \r\n  Removes object `obj` from the collection.\r\n* `list([tx], callback)`  \r\n  Asynchronously fetches the results matching the formulated query.\r\n  Once retrieved, the callback function is invoked with an array of\r\n  entity objects as argument.\r\n* `each([tx], eachCallback)`  \r\n  Asynchronously fetches the results matching the formulated query.\r\n  Once retrieved, the `eachCallback` function is invoked on each\r\n  element of the result objects.\r\n* `forEach([tx], eachCallback)`  \r\n  Alias for `each`\r\n* `one([tx], callback)`\r\n  Asynchronously fetches the first element of the collection, or `null` if none.\r\n* `destroyAll([tx], callback)`\r\n  Asynchronously removes all the items in the collection. __Important__: this does\r\n  not only remove the items from the collection, but removes the items themselves!\r\n* `count([tx], callback)`\r\n  Asynchronously counts the number of items in the collection. The arguments passed\r\n  to the `callback` function is the number of items.\r\n\r\nQuery collections are returned by:\r\n\r\n* `EntityName.all()`, e.g. `Task.all()`\r\n* one-to-many and many-to-many relationships, e.g. `task.tags`\r\n\r\nExample:\r\n\r\n    var allTasks = Task.all().filter(\"done\", '=', true).prefetch(\"category\").order(\"name\", false).limit(10);\r\n        \r\n    allTasks.list(null, function (results) {\r\n        results.forEach(function (r) {\r\n            console.log(r.name)\r\n            window.task = r;\r\n        });\r\n    });\r\n\r\nUsing persistence.js on the server\r\n==================================\r\n\r\nInstalling `persistence.js` on node is easy using [npm](http://npmjs.org):\r\n\r\n    npm install persistencejs\r\n\r\nSadly the node.js server environment requires slight changes to\r\n`persistence.js` to make it work with multiple database connections:\r\n\r\n* A `Session` object needs to be passed as an extra argument to\r\n  certain method calls, typically as a first argument.\r\n* Methods previously called on the `persistence` object itself are now\r\n  called on the `Session` object.\r\n\r\nAn example `node.js` application is included in `test/node-blog.js`. \r\n\r\nSetup\r\n-----\r\nYou need to `require` two modules, the `persistence.js` library itself\r\nand the MySQL backend module.\r\n\r\n    var persistence = require('persistencejs/persistence').persistence;\r\n    var persistenceStore = require('persistencejs/persistence.store.mysql');\r\n\r\nThen, you configure the database settings to use:\r\n\r\n    persistenceStore.config(persistence, 'localhost', 3306, 'dbname', 'username', 'password');\r\n\r\nSubsequently, for every connection you handle (assuming you're\r\nbuilding a sever), you call the `persistenceStore.getSession()`\r\nmethod:\r\n\r\n    var session = persistenceStore.getSession();\r\n\r\nThis session is what you pass around, typically together with a\r\ntransaction object. Note that currently you can only have one\r\ntransaction open per session and transactions cannot be nested.\r\n\r\n    session.transaction(function(tx) {\r\n      ...\r\n    });\r\n\r\nCommit and Rollback\r\n-------------------\r\n\r\n`persistence.js` works in autocommit mode by default. \r\n\r\nYou can override this behavior and enable explicit commit and rollback \r\nby passing true as first argument to `persistence.transaction`. \r\nYou can then use the following two methods to control the transaction:\r\n\r\n* `transaction.commit(session, callback)` commits the changes.\r\n* `transaction.rollback(session, callback)` rollbacks the changes.\r\n\r\nTypical code will look like:\r\n \r\n    session.transaction(true, function(tx) {\r\n      // create/update/delete objects\r\n      modifyThings(session, tx, function(err, result) {\r\n        if (err) {\r\n          // something went wrong\r\n          tx.rollback(session, function() {\r\n            console.log('changes have been rolled back: ' + ex.message);\r\n          });\r\n        }\r\n        else {\r\n          // success\r\n          tx.commit(session, function() {\r\n            console.log('changes have been committed: ' result);\r\n        });\r\n      });\r\n    });\r\n\r\nExplicit commit and rollback is only supported on MySQL (server side) \r\nfor now.\r\n\r\nDefining your data model\r\n------------------------\r\n\r\nDefining your data model is done in exactly the same way as regular `persistence.js`:\r\n\r\n    var Task = persistence.define('Task', {\r\n      name: \"TEXT\",\r\n      description: \"TEXT\",\r\n      done: \"BOOL\"\r\n    });\r\n\r\nA `schemaSync` is typically performed as follows:\r\n\r\n    session.schemaSync(tx, function() {\r\n      ...\r\n    });\r\n\r\nCreating and manipulating objects\r\n---------------------------------\r\n\r\nCreating and manipulating objects is done much the same way as with\r\nregular `persistence.js`, except that in the entity's constructor you\r\nneed to reference the `Session` again:\r\n\r\n    var t = new Task(session);\r\n    ...\r\n    session.add(t);\r\n\r\n    session.flush(tx, function() {\r\n      ...\r\n    });\r\n\r\nQuery collections\r\n-----------------\r\n\r\nQuery collections work the same way as in regular `persistence.js`\r\nwith the exception of the `Entity.all()` method that now also requires\r\na `Session` to be passed to it:\r\n\r\n    Task.all(session).filter('done', '=', true).list(tx, function(tasks) {\r\n      ...\r\n    });\r\n\r\nClosing the session\r\n-------------------\r\n\r\nAfter usage, you need to close your session:\r\n\r\n    session.close();\r\n\r\nBugs and Contributions\r\n======================\r\n\r\nIf you find a bug, please [report\r\nit](https://github.com/zefhemel/persistencejs/issues).  or fork the\r\nproject, fix the problem and send me a pull request. For a list of\r\nplanned features and open issues, have a look at the [issue\r\ntracker](https://github.com/zefhemel/persistencejs/issues).\r\n\r\nFor support and discussion, please join the [persistence.js Google\r\nGroup](http://groups.google.com/group/persistencejs).\r\n\r\nThanks goes to the people listed in `AUTHORS` for their contributions.\r\n\r\nIf you use [GWT](http://code.google.com/webtoolkit/) (the Google Web\r\nToolkit), be sure to have a look at [Dennis Z. Jiang's GWT persistence.js\r\nwrapper](http://github.com/dennisjzh/GwtMobile-Persistence)\r\n\r\nLicense\r\n=======\r\n\r\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\r\n\r\nSupport this work\r\n-----------------\r\n\r\nYou can support this project by flattering it:\r\n\r\n<a href=\"http://flattr.com/thing/2510/persistence-js\" target=\"_blank\">\r\n<img src=\"http://api.flattr.com/button/button-static-50x60.png\" title=\"Flattr this\" border=\"0\" /></a>\r\n",
  "readmeFilename": "README.md",
  "description": "persistence.js\r ==============\r `persistence.js` is a asynchronous Javascript object-relational\r mapper library. It can be used both in the web browser and on\r the server using [node.js](http://nodejs.org). It currently\r supports 4 types of data stores:",
  "_id": "persistencejs@0.2.5",
  "_from": "persistencejs@"
}
